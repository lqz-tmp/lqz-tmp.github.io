<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.0 -->
    <script>
        window.materialVersion = "1.5.0"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Title -->
    
    <title>
        
            Pascal 转 C++ 教程1 | 
        
        Lqz&#39;blog
    </title>

    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="format-detection" content="telephone=no"/>
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="lqz">
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content=",教程">

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(key){try{localStorage.removeItem(key)}catch(e){}};lsloader.setLS=function(key,val){try{localStorage.setItem(key,val)}catch(e){}};lsloader.getLS=function(key){var val="";try{val=localStorage.getItem(key)}catch(e){val=""}return val};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var keys=[];for(var i=0;i<localStorage.length;i++){keys.push(localStorage.key(i))}keys.forEach(function(key){var data=lsloader.getLS(key);if(window.oldVersion){var remove=window.oldVersion.reduce(function(p,c){return p||data.indexOf("/*"+c+"*/")!==-1},false);if(remove){lsloader.removeLS(key)}}})}catch(e){}};lsloader.clean();lsloader.load=function(jsname,jspath,cssonload,isJs){if(typeof cssonload==="boolean"){isJs=cssonload;cssonload=undefined}isJs=isJs||false;cssonload=cssonload||function(){};var code;code=this.getLS(jsname);if(code&&code.indexOf(versionString)===-1){this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload,isJs);return}if(code){var versionNumber=code.split(versionString)[0];if(versionNumber!=jspath){console.log("reload:"+jspath);this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload,isJs);return}code=code.split(versionString)[1];if(isJs){this.jsRunSequence.push({name:jsname,code:code});this.runjs(jspath,jsname,code)}else{document.getElementById(jsname).appendChild(document.createTextNode(code));cssonload()}}else{this.requestResource(jsname,jspath,cssonload,isJs)}};lsloader.requestResource=function(name,path,cssonload,isJs){var that=this;if(isJs){this.iojs(path,name,function(path,name,code){that.setLS(name,path+versionString+code);that.runjs(path,name,code)})}else{this.iocss(path,name,function(code){document.getElementById(name).appendChild(document.createTextNode(code));that.setLS(name,path+versionString+code)},cssonload)}};lsloader.iojs=function(path,jsname,callback){var that=this;that.jsRunSequence.push({name:jsname,code:""});try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(path,jsname,xhr.response);return}}that.jsfallback(path,jsname)}};xhr.send(null)}catch(e){that.jsfallback(path,jsname)}};lsloader.iocss=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.iofonts=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.runjs=function(path,name,code){if(!!name&&!!code){for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code=code}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var script=document.createElement("script");script.appendChild(document.createTextNode(this.jsRunSequence[0].code));script.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(script);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var that=this;var script=document.createElement("script");script.src=this.jsRunSequence[0].path;script.type="text/javascript";this.jsRunSequence[0].status="loading";script.onload=function(){that.jsRunSequence.shift();if(that.jsRunSequence.length>0){that.runjs()}};document.body.appendChild(script)}};lsloader.tagLoad=function(path,name){this.jsRunSequence.push({name:name,code:"",path:path,status:"failed"});this.runjs()};lsloader.jsfallback=function(path,name){if(!!this.jsnamemap[name]){return}else{this.jsnamemap[name]=name}for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code="";this.jsRunSequence[k].status="failed";this.jsRunSequence[k].path=path}}this.runjs()};lsloader.cssfallback=function(path,name,cssonload){if(!!this.cssnamemap[name]){return}else{this.cssnamemap[name]=1}var link=document.createElement("link");link.type="text/css";link.href=path;link.rel="stylesheet";link.onload=link.onerror=cssonload;var root=document.getElementsByTagName("script")[0];root.parentNode.insertBefore(link,root)};lsloader.runInlineScript=function(scriptId,codeId){var code=document.getElementById(codeId).innerText;this.jsRunSequence.push({name:scriptId,code:code});this.runjs()};lsloader.loadCombo=function(jslist){var updateList="";var requestingModules={};for(var k in jslist){var LS=this.getLS(jslist[k].name);if(!!LS){var version=LS.split(versionString)[0];var code=LS.split(versionString)[1]}else{var version=""}if(version==jslist[k].path){this.jsRunSequence.push({name:jslist[k].name,code:code,path:jslist[k].path})}else{this.jsRunSequence.push({name:jslist[k].name,code:null,path:jslist[k].path,status:"comboloading"});requestingModules[jslist[k].name]=true;updateList+=(updateList==""?"":";")+jslist[k].path}}var that=this;if(!!updateList){var xhr=new XMLHttpRequest;xhr.open("get",combo+updateList,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){that.runCombo(xhr.response,requestingModules);return}}else{for(var i in that.jsRunSequence){if(requestingModules[that.jsRunSequence[i].name]){that.jsRunSequence[i].status="failed"}}that.runjs()}}};xhr.send(null)}this.runjs()};lsloader.runCombo=function(comboCode,requestingModules){comboCode=comboCode.split("/*combojs*/");comboCode.shift();for(var k in this.jsRunSequence){if(!!requestingModules[this.jsRunSequence[k].name]&&!!comboCode[0]){this.jsRunSequence[k].status="comboJS";this.jsRunSequence[k].code=comboCode[0];this.setLS(this.jsRunSequence[k].name,this.jsRunSequence[k].path+versionString+comboCode[0]);comboCode.shift()}}this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="https://ws1.sinaimg.cn/large/005wa3kugy1fu0b6e5qelj30go0goaa6.jpg">
    <link rel="icon" sizes="192x192" href="https://ws1.sinaimg.cn/large/005wa3kugy1fu0b6e5qelj30go0goaa6.jpg">
    <link rel="apple-touch-icon" href="https://ws1.sinaimg.cn/large/005wa3kugy1fu0b6e5qelj30go0goaa6.jpg">

    <!--iOS -->
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Lqz&#39;blog">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        
            
                <style id="prettify_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_css","/css/prettify.min.css?zp8STOU9v89XWFEnN+6YmQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
                <style id="prettify_theme"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_theme","/css/prettify/hemisu-light.min.css?VObWVMCVqUayV6JD/9Xz9w==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
            
        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icon -->

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://lqz-tmp.github.io">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Pascal 转 C++ 教程1 | Lqz&#39;blog">
    <meta property="og:image" content="http://lqz-tmp.github.iohttps://ws1.sinaimg.cn/large/005wa3kugy1fu0b6e5qelj30go0goaa6.jpg" />
    <meta property="og:description" content="">
    <meta property="og:article:tag" content="教程"> 

    
        <meta property="article:published_time" content="Mon Aug 06 2018 20:07:47 GMT+0800" />
        <meta property="article:modified_time" content="Mon Aug 06 2018 20:27:56 GMT+0800" />
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:title" content="Pascal 转 C++ 教程1 | Lqz&#39;blog">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="http://lqz-tmp.github.iohttps://ws1.sinaimg.cn/large/005wa3kugy1fu0b6e5qelj30go0goaa6.jpg">
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="http://lqz-tmp.github.io" />

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://lqz-tmp.github.io/2018/08/06/教程1/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://lqz-tmp.github.io/2018/08/06/教程1/index.html",
    "headline": "Pascal 转 C++ 教程1",
    "datePublished": "Mon Aug 06 2018 20:07:47 GMT+0800",
    "dateModified": "Mon Aug 06 2018 20:27:56 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "lqz",
        "image": {
            "@type": "ImageObject",
            "url": "https://ws1.sinaimg.cn/large/005wa3kugy1fu0b7kqj80j30e80e874f.jpg"
        },
        "description": "Hi, nice to meet you"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Lqz&#39;blog",
        "logo": {
            "@type":"ImageObject",
            "url": "https://ws1.sinaimg.cn/large/005wa3kugy1fu0b6e5qelj30go0goaa6.jpg"
        }
    },
    "keywords": ",教程",
    "description": "",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Pascal-转-C-教程1"><span class="post-toc-number">1.</span> <span class="post-toc-text">Pascal 转 C++ 教程1</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#C-程序结构、数据结构、语法、函数"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">C++ 程序结构、数据结构、语法、函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#一个标准的C-程序："><span class="post-toc-number">1.1.0.1.</span> <span class="post-toc-text">一个标准的C++程序：</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#语法"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">语法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#花括号和分号"><span class="post-toc-number">1.2.0.1.</span> <span class="post-toc-text">花括号和分号</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注释"><span class="post-toc-number">1.2.0.2.</span> <span class="post-toc-text">注释</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#预处理指令（-开头）"><span class="post-toc-number">1.2.0.3.</span> <span class="post-toc-text">预处理指令（#开头）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#头文件"><span class="post-toc-number">1.2.0.4.</span> <span class="post-toc-text">头文件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#OI竞赛中可能会用到的头文件"><span class="post-toc-number">1.2.0.5.</span> <span class="post-toc-text">OI竞赛中可能会用到的头文件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#主函数"><span class="post-toc-number">1.2.0.6.</span> <span class="post-toc-text">主函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#基本类型"><span class="post-toc-number">1.2.0.7.</span> <span class="post-toc-text">基本类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#带符号整型"><span class="post-toc-number">1.2.0.8.</span> <span class="post-toc-text">带符号整型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#无符号整型"><span class="post-toc-number">1.2.0.9.</span> <span class="post-toc-text">无符号整型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实型、字符型和布尔型"><span class="post-toc-number">1.2.0.10.</span> <span class="post-toc-text">实型、字符型和布尔型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#各种类型占用的字节数"><span class="post-toc-number">1.2.0.11.</span> <span class="post-toc-text">各种类型占用的字节数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#各种类型的常量"><span class="post-toc-number">1.2.0.12.</span> <span class="post-toc-text">各种类型的常量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#其他进制的整型常量"><span class="post-toc-number">1.2.0.13.</span> <span class="post-toc-text">其他进制的整型常量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#转义字符"><span class="post-toc-number">1.2.0.14.</span> <span class="post-toc-text">转义字符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定义基本类型的变量"><span class="post-toc-number">1.2.0.15.</span> <span class="post-toc-text">定义基本类型的变量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#隐式类型转换"><span class="post-toc-number">1.2.0.16.</span> <span class="post-toc-text">隐式类型转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#显式类型转换"><span class="post-toc-number">1.2.0.17.</span> <span class="post-toc-text">显式类型转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#基本类型间的转换"><span class="post-toc-number">1.2.0.18.</span> <span class="post-toc-text">基本类型间的转换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#注意有些转换可能会溢出，例如unsigned-gt-int，long-long-gt-int等"><span class="post-toc-number">1.2.0.18.0.1.</span> <span class="post-toc-text">注意有些转换可能会溢出，例如unsigned-&gt;int，long long-&gt;int等</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#指针类型"><span class="post-toc-number">1.2.0.19.</span> <span class="post-toc-text">指针类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#引用类型"><span class="post-toc-number">1.2.0.20.</span> <span class="post-toc-text">引用类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#注意点"><span class="post-toc-number">1.2.0.20.0.1.</span> <span class="post-toc-text">注意点</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#const类型"><span class="post-toc-number">1.2.0.21.</span> <span class="post-toc-text">const类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#类型的别名"><span class="post-toc-number">1.2.0.22.</span> <span class="post-toc-text">类型的别名</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CPU的字长"><span class="post-toc-number">1.2.0.23.</span> <span class="post-toc-text">CPU的字长</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#原码、反码和补码"><span class="post-toc-number">1.2.0.24.</span> <span class="post-toc-text">原码、反码和补码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#练习题1"><span class="post-toc-number">1.2.0.25.</span> <span class="post-toc-text">练习题1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#练习题2"><span class="post-toc-number">1.2.0.26.</span> <span class="post-toc-text">练习题2</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#运算"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#四则运算符、取模"><span class="post-toc-number">1.3.0.1.</span> <span class="post-toc-text">四则运算符、取模</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#逻辑运算符"><span class="post-toc-number">1.3.0.2.</span> <span class="post-toc-text">逻辑运算符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#位运算"><span class="post-toc-number">1.3.0.3.</span> <span class="post-toc-text">位运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#amp-、-和-amp-amp-、"><span class="post-toc-number">1.3.0.3.0.1.</span> <span class="post-toc-text">&amp;、|和&amp;&amp;、||</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#赋值运算符"><span class="post-toc-number">1.3.0.4.</span> <span class="post-toc-text">赋值运算符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#表达式"><span class="post-toc-number">1.3.0.5.</span> <span class="post-toc-text">表达式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#和–"><span class="post-toc-number">1.3.0.6.</span> <span class="post-toc-text">++和–</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注意：-和–"><span class="post-toc-number">1.3.0.7.</span> <span class="post-toc-text">注意：++和–</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#逗号运算符"><span class="post-toc-number">1.3.0.8.</span> <span class="post-toc-text">逗号运算符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#new和delete"><span class="post-toc-number">1.3.0.9.</span> <span class="post-toc-text">new和delete</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#运算符优先级"><span class="post-toc-number">1.3.0.10.</span> <span class="post-toc-text">运算符优先级</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#练习题"><span class="post-toc-number">1.3.0.11.</span> <span class="post-toc-text">练习题</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#读入、输出"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">读入、输出</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#C语言中的读入输出函数"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">C语言中的读入输出函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#scanf函数"><span class="post-toc-number">1.4.1.1.</span> <span class="post-toc-text">scanf函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#格式字符"><span class="post-toc-number">1.4.1.1.0.1.</span> <span class="post-toc-text">格式字符</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#printf函数"><span class="post-toc-number">1.4.1.2.</span> <span class="post-toc-text">printf函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#scanf函数和printf函数的返回值"><span class="post-toc-number">1.4.1.3.</span> <span class="post-toc-text">scanf函数和printf函数的返回值</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#C-语言的读入输出字符"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">C++语言的读入输出字符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#C-语言的读入输出流"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">C++语言的读入输出流</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#cin-cout"><span class="post-toc-number">1.4.3.1.</span> <span class="post-toc-text">cin/cout</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#输出流控制"><span class="post-toc-number">1.4.3.2.</span> <span class="post-toc-text">输出流控制</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#cin-get-cin-getline"><span class="post-toc-number">1.4.3.3.</span> <span class="post-toc-text">cin.get()/cin.getline()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#如何选择读入输出方式"><span class="post-toc-number">1.4.3.4.</span> <span class="post-toc-text">如何选择读入输出方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#练习题-1"><span class="post-toc-number">1.4.3.5.</span> <span class="post-toc-text">练习题</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数据结构、常用函数"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">数据结构、常用函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#数组"><span class="post-toc-number">1.5.0.1.</span> <span class="post-toc-text">数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#数组的长度"><span class="post-toc-number">1.5.0.1.0.1.</span> <span class="post-toc-text">数组的长度</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#一维数组和指针的关系"><span class="post-toc-number">1.5.0.2.</span> <span class="post-toc-text">一维数组和指针的关系</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#指针的加减法"><span class="post-toc-number">1.5.0.3.</span> <span class="post-toc-text">指针的加减法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#再谈new和delete"><span class="post-toc-number">1.5.0.4.</span> <span class="post-toc-text">再谈new和delete</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#高维数组"><span class="post-toc-number">1.5.0.5.</span> <span class="post-toc-text">高维数组</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#C风格字符串"><span class="post-toc-number">1.5.0.6.</span> <span class="post-toc-text">C风格字符串</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#读入、输出C风格字符串"><span class="post-toc-number">1.5.0.7.</span> <span class="post-toc-text">读入、输出C风格字符串</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#其他读入输出函数"><span class="post-toc-number">1.5.0.8.</span> <span class="post-toc-text">其他读入输出函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#cstring头文件"><span class="post-toc-number">1.5.0.9.</span> <span class="post-toc-text">cstring头文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#strlen函数"><span class="post-toc-number">1.5.0.9.1.</span> <span class="post-toc-text">strlen函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#strcmp函数"><span class="post-toc-number">1.5.0.9.2.</span> <span class="post-toc-text">strcmp函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#strcat函数"><span class="post-toc-number">1.5.0.9.3.</span> <span class="post-toc-text">strcat函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#strcpy函数"><span class="post-toc-number">1.5.0.9.4.</span> <span class="post-toc-text">strcpy函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么时候使用C风格字符串？"><span class="post-toc-number">1.5.0.10.</span> <span class="post-toc-text">什么时候使用C风格字符串？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#memset函数"><span class="post-toc-number">1.5.0.11.</span> <span class="post-toc-text">memset函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#memcpy函数"><span class="post-toc-number">1.5.0.12.</span> <span class="post-toc-text">memcpy函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#memset和memcpy的注意点"><span class="post-toc-number">1.5.0.12.0.1.</span> <span class="post-toc-text">memset和memcpy的注意点</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#分清指针和数组名"><span class="post-toc-number">1.5.0.12.0.2.</span> <span class="post-toc-text">分清指针和数组名</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#初始化数组"><span class="post-toc-number">1.5.0.13.</span> <span class="post-toc-text">初始化数组</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#常量数组"><span class="post-toc-number">1.5.0.14.</span> <span class="post-toc-text">常量数组</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#结构体"><span class="post-toc-number">1.5.0.15.</span> <span class="post-toc-text">结构体</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#枚举类型"><span class="post-toc-number">1.5.0.16.</span> <span class="post-toc-text">枚举类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#练习题1-1"><span class="post-toc-number">1.5.0.17.</span> <span class="post-toc-text">练习题1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#练习题2-1"><span class="post-toc-number">1.5.0.18.</span> <span class="post-toc-text">练习题2</span></a></li></ol></li></ol></li></ol></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Pure Thumbnail -->
            <div class="post_thumbnail-pure mdl-card__media mdl-color-text--grey-50" style="background-color:#549eae !important">
        
    
            <p class="article-headline-p">
                Pascal 转 C++ 教程1
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="https://ws1.sinaimg.cn/large/005wa3kugy1fu0b7kqj80j30e80e874f.jpg" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>lqz</strong>
        <span>8月 06, 2018</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/教程/">教程</a>
    </ul>
    

    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=Pascal 转 C++ 教程1&url=http://lqz-tmp.github.io/2018/08/06/教程1/index.html&pic=http://lqz-tmp.github.iohttps://ws1.sinaimg.cn/large/005wa3kugy1fu0b6e5qelj30go0goaa6.jpg&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=Pascal 转 C++ 教程1&url=http://lqz-tmp.github.io/2018/08/06/教程1/index.html&via=lqz" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://lqz-tmp.github.io/2018/08/06/教程1/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://lqz-tmp.github.io/2018/08/06/教程1/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    
        <a class="post_share-link" href="https://www.linkedin.com/shareArticle?mini=true&url=http://lqz-tmp.github.io/2018/08/06/教程1/index.html&title=Pascal 转 C++ 教程1" target="_blank">
            <li class="mdl-menu__item">
                分享到 LinkedIn
            </li>
        </a>
    

    <!-- Share QQ -->
    
        <a class="post_share-link" href="http://connect.qq.com/widget/shareqq/index.html?site=Lqz&#39;blog&title=Pascal 转 C++ 教程1&summary=&pics=http://lqz-tmp.github.iohttps://ws1.sinaimg.cn/large/005wa3kugy1fu0b6e5qelj30go0goaa6.jpg&url=http://lqz-tmp.github.io/2018/08/06/教程1/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 QQ
            </li>
        </a>
    

    <!-- Share Telegram -->
    
        <a class="post_share-link" href="https://telegram.me/share/url?url=http://lqz-tmp.github.io/2018/08/06/教程1/index.html&text=Pascal 转 C++ 教程1" target="_blank">
            <li class="mdl-menu__item">
                分享到 Telegram
            </li>
        </a>
    
</ul>

</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h1 id="Pascal-转-C-教程1"><a href="#Pascal-转-C-教程1" class="headerlink" title="Pascal 转 C++ 教程1"></a>Pascal 转 C++ 教程1</h1><h2 id="C-程序结构、数据结构、语法、函数"><a href="#C-程序结构、数据结构、语法、函数" class="headerlink" title="C++ 程序结构、数据结构、语法、函数"></a>C++ 程序结构、数据结构、语法、函数</h2><h4 id="一个标准的C-程序："><a href="#一个标准的C-程序：" class="headerlink" title="一个标准的C++程序："></a>一个标准的C++程序：</h4><pre><code class="c++">    #include &lt;cstdio&gt;
    #define maxn 1000   // 预处理指令
    using namespace std;
    int a[maxn];        // maxn被替换为1000
    int main() {        // 主函数
       int n;
       scanf(&quot;%d&quot;, &amp;n);
       for (int i = 0; i &lt; n; i ++)
           scanf(&quot;%d&quot;, &amp;a[i]);
       for (int i = 0; i &lt; n; i ++)
           printf(&quot;%d\n&quot;, a[i]);
       return 0;
    }
</code></pre>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h4 id="花括号和分号"><a href="#花括号和分号" class="headerlink" title="花括号和分号"></a>花括号和分号</h4><p>   <code>{</code>相当于Pascal中的begin，<code>}</code>相当于Pascal中的end，语句和Pascal语言一样用<code>;</code>分隔，一般一行写一条语句。</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>   C++中有两种方法使用注释（不编译的内容）。<br>   <code>//</code>后到行尾的内容为注释（和Pascal中的//一样）。<br>   <code>/*</code>和<code>*/</code>中间的内容为注释，相当于Pascal中的<code>{</code>和<code>}</code>。</p>
<h4 id="预处理指令（-开头）"><a href="#预处理指令（-开头）" class="headerlink" title="预处理指令（#开头）"></a>预处理指令（#开头）</h4><p>   头文件（#include）<br>   宏定义（#define）</p>
<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><p>   OI竞赛中会用到的标准头文件有两类：<code>继承自C的头文件</code>和<code>STL头文件</code>。C的头文件一般以<code>c</code>开头，例如前面的<code>cstdio</code>。</p>
<h4 id="OI竞赛中可能会用到的头文件"><a href="#OI竞赛中可能会用到的头文件" class="headerlink" title="OI竞赛中可能会用到的头文件"></a>OI竞赛中可能会用到的头文件</h4><ul>
<li>cstdio：包含读入输出相关函数，可以记为c+std(standard)+io(input&amp;output)。一般来说这个头文件必然要包含。  </li>
<li>cstring：包含C-style字符串相关的函数。  </li>
<li>cmath：包含数学相关的函数。  </li>
<li>cstdlib：包括随机函数等。  </li>
<li>ctime：获取时间当做随机函数的种子。  </li>
<li>STL头文件：后面会详细介绍STL。  </li>
</ul>
<h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><p>   和Pascal中的主程序一样，是程序开始执行的地方。不同的地方是C++的主函数有返回值，类型为<code>int</code>，并且正常结束时应该返回0。<br>   在其他函数中，也可以用<code>cstdlib</code>头文件中的函数<code>exit(0)</code>直接退出整个程序，其中的参数<code>0</code>表示的就是主函数返回值。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul>
<li>整型  </li>
<li>实型  </li>
<li>字符型  </li>
<li>布尔型  </li>
</ul>
<h4 id="带符号整型"><a href="#带符号整型" class="headerlink" title="带符号整型"></a>带符号整型</h4><p>   <strong>int、short、long、long long</strong> </p>
<ul>
<li><code>int</code>和<code>long</code>为32位带符号整型（Pascal中的longint），范围是<code>-2^31~2^31-1</code>。  </li>
<li><code>short</code>为16位带符号整型（Pascal中的integer），范围是<code>-2^15~2^15-1</code>。  </li>
<li><code>long long</code>为64位带符号整型（Pascal中的int64），范围是<code>-2^63~2^63-1</code>。  </li>
<li>int的最大值约为2.1×109，为<code>首选整型</code>类型。  </li>
</ul>
<h4 id="无符号整型"><a href="#无符号整型" class="headerlink" title="无符号整型"></a>无符号整型</h4><p>   在对应的带符号整型前面加上<code>unsigned</code>，也就是unsigned int、unsigned short、unsigned long、unsigned long long。其中<code>unsigned int</code>可以直接写为<code>unsigned</code>。<br>   无符号整型不能存储负数，但存储的最大值可以扩大一倍，例如unsigned的范围就是0~2^32-1。  </p>
<h4 id="实型、字符型和布尔型"><a href="#实型、字符型和布尔型" class="headerlink" title="实型、字符型和布尔型"></a>实型、字符型和布尔型</h4><ul>
<li>C++中有<code>float</code>、<code>double</code>和<code>long double</code>三种实型，精度依次递增，一般使用<code>double</code>。  </li>
<li><code>char</code>类型只能存储字符，计算机内部是用<code>ASCII码</code>表示字符的，实际的范围是<code>0~255</code>。字符常量使用<code>单引号</code>包围的。  </li>
<li><code>bool</code>型只能为<code>true</code>或<code>false</code>。  </li>
</ul>
<h4 id="各种类型占用的字节数"><a href="#各种类型占用的字节数" class="headerlink" title="各种类型占用的字节数"></a>各种类型占用的字节数</h4><ul>
<li>1字节：char、bool</li>
<li>2字节：short、unsigned short</li>
<li>4字节：int、unsigned、long、unsigned long、float</li>
<li>8字节：long long、unsigned long long、double</li>
<li>12字节：long double</li>
</ul>
<h4 id="各种类型的常量"><a href="#各种类型的常量" class="headerlink" title="各种类型的常量"></a>各种类型的常量</h4><ul>
<li>int类型的常量：2、100等（不需要任何后缀）</li>
<li>double类型的常量：0.0、1.5、1e50等</li>
<li>char类型的常量：’a’、’d’等（将字符夹在单引号间）</li>
<li>bool类型的常量：true和false</li>
<li>unsigned类型的常量：50u、50U（在非负整数后加上u或U后缀）</li>
<li>long long类型的常量：1000ll、1000LL</li>
</ul>
<h4 id="其他进制的整型常量"><a href="#其他进制的整型常量" class="headerlink" title="其他进制的整型常量"></a>其他进制的整型常量</h4><ul>
<li>十六进制前加0x前缀，例如0x100f、0x100F（大写小写均可）。</li>
<li>八进制前加0前缀，例如0144，它表示八进制的144，十进制的值是100。因此不要随便加多余的零，防止被当做八进制处理。</li>
</ul>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>   某些特殊的字符可以用转义的方法表示。转义字符以反斜杠()开头，例如<code>\n</code>。下面是比较常见的五种转义字符：</p>
<ul>
<li><code>\n</code> 换行</li>
<li><code>\\</code> 反斜杠</li>
<li><code>\?</code> 问号</li>
<li><code>\&#39;</code> 单引号</li>
<li><code>\&quot;</code> 双引号</li>
</ul>
<h4 id="定义基本类型的变量"><a href="#定义基本类型的变量" class="headerlink" title="定义基本类型的变量"></a>定义基本类型的变量</h4><ul>
<li>定义变量的方式为类型名+变量名：<ul>
<li>int x1, y1;</li>
<li>char x2, y2;</li>
<li>double x3, y3;</li>
<li>bool x4, y4;</li>
</ul>
</li>
<li>定义变量时也可以直接指定初值：<ul>
<li>int a = 10;</li>
<li>char b = ‘p’;</li>
<li>double c = 1.2;</li>
<li>long long d = 1000LL;</li>
<li>bool e = true;</li>
</ul>
</li>
<li>定义基本类型的变量<ul>
<li>C++语言几乎可以在程序的任何地方定义变量，但定义的变量只有在定义之后才能使用，如果在定义处之前就使用会给出编译错误。</li>
</ul>
</li>
</ul>
<h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><ul>
<li>假如将A类型的变量或常量赋值给B类型的变量，A类型就会被隐式地转换为B类型。</li>
<li>两个不同类型进行二元运算时，小类型也会被隐式转换成大类型以便运算。<pre><code class="c++">int a = 100;
long long b = a;
// int类型的a被隐式转换为long long类型后赋值给b
double x = 1.5;
int y = 10;
double z = x * y;
// int类型的y被隐式转换为double类型后和x相乘
</code></pre>
</li>
</ul>
<h4 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h4><ul>
<li>除了隐式类型转换，在需要的时候，我们也可以显式地对变量的类型进行转换。其实我也比较推荐大家尽量使用显式类型转换，这样可以避免某些可能的错误。显示转换的方法是(type)x，其中type是要转换成的类型。假如后面要转换的是一个表达式，需要加上括号，即<code>(type)(a+b)</code>，这是由于运算符优先级的问题，后面会再次提到。<pre><code class="c++">int a = 1000000000;
long long b = (long long)a * a;
</code></pre>
</li>
<li>这里int类型的a被显式转换成long long类型后和int类型的a相乘，由于相乘的两个类型不同，后面int类型的a会被隐式转换成long long类型后再与前面的a相乘。这里不进行显式类型转换的话，由于相乘的两个类型都是int，就会发生溢出，不过溢出这种错误运行时并不会报错。</li>
</ul>
<h4 id="基本类型间的转换"><a href="#基本类型间的转换" class="headerlink" title="基本类型间的转换"></a>基本类型间的转换</h4><ul>
<li>实型-&gt;整型：去除小数部分，仅保留整数部分</li>
<li>整型-&gt;实型：无变化，精度可能会损失</li>
<li>整型<->字符型：ASCII码</-></li>
<li>布尔型-&gt;整型：true变成1，false变成0</li>
<li>整型-&gt;布尔型：0变成false，其他变成true</li>
</ul>
<h6 id="注意有些转换可能会溢出，例如unsigned-gt-int，long-long-gt-int等"><a href="#注意有些转换可能会溢出，例如unsigned-gt-int，long-long-gt-int等" class="headerlink" title="注意有些转换可能会溢出，例如unsigned-&gt;int，long long-&gt;int等"></a>注意有些转换可能会溢出，例如unsigned-&gt;int，long long-&gt;int等</h6><ul>
<li><strong>由于有隐式类型转换，将数字字符转换成数字可以直接写成ch-‘0’，类似的还有ch-‘a’，其中ch表示数字字符或小写字母字符。</strong></li>
<li><strong>假如要从大类型转换为小类型（如long long转换为int、double转换为int），因为精度可能会损失，建议使用显式类型转换提示自己。</strong></li>
</ul>
<h4 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h4><p>   指针是指向特定类型内存地址的类型。C++中的&amp;运算符可以取出某个变量在内存中的地址，以便赋值给相应的指针类型。后面讲运算符时还会介绍通过new的方式给指针赋值。空指针的值为0（也可以用NULL表示）。  </p>
<pre><code class="c++">    int a = 100;
    int *b = &amp;a;
    // b是一个指向int类型的指针
    // 并且将它初始化为a变量的地址
    *b = *b * 2;
    // 相当于a变量被乘2了
    int *c = 0; // c是一个空指针
    *c = *c * 2; // 运行到这条时会错误
</code></pre>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>   引用和指针有相似的地方，但更恰当的理解是给变量取别名。<strong>引用在定义时必须被恰当地初始化，并且之后就不能再修改成其他变量的别名。</strong>  </p>
<pre><code class="c++">    int a = 100;
    int &amp;b = a;
    // b是一个int的引用类型
    // 并且它被初始化指向a
    b = b * 2;
    // 相当于a变量被乘2了
</code></pre>
<h6 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h6><ul>
<li>引用指针类型指向的地址时，需要在指针变量名前加<code>*</code>，但引用是和普通变量一样直接使用。</li>
<li>定义指针和引用变量时需注意，每一个指针或引用变量前都要加<code>*</code>或<code>&amp;</code>。<pre><code class="c++">int *a, b, &amp;c = b;
// a是指向int的指针类型
// b是普通的int类型
// c是指向int的引用类型
</code></pre>
</li>
</ul>
<h4 id="const类型"><a href="#const类型" class="headerlink" title="const类型"></a>const类型</h4><p>   和Pascal中一样，C++里也可以定义常量，适当地定义常量不仅方便编程，也能够使程序意义更明确  </p>
<pre><code class="c++">    const double pi = 3.141592653;
    const int inf = 1000000000;
    const char space = &#39; &#39;;
</code></pre>
<p>   常量定义后就不能够再修改，除了直接输入常量的值，也可以通过<strong>常量表达式</strong>定义常量。  </p>
<pre><code class="c++">    const double pi = acos(-1);
    const int inf = 10000 * 10000;
</code></pre>
<h4 id="类型的别名"><a href="#类型的别名" class="headerlink" title="类型的别名"></a>类型的别名</h4><p>   对于某些很长的类型名，可以通过typedef在使用类型之前取别名，例如：<br>   <code>typedef long long LL;</code><br>   这样LL就可以直接表示long long类型了。<br>   再例如：<br>   <code>typedef int* pint;</code><br>   就可以用pint来表示指向int的指针了。  </p>
<h4 id="CPU的字长"><a href="#CPU的字长" class="headerlink" title="CPU的字长"></a>CPU的字长</h4><ul>
<li>CPU在单位时间内能一次处理的二进制数的位数。</li>
<li>当前的CPU基本都支持64位字长，但由于操作系统是32位的，因此当前绝大多数64位CPU都运行在了32位字长的模式下。</li>
<li>C++中的<code>int</code>类型就是32位长的，也就是占用4字节（8个位为一个字节）。它和CPU的字长相同，可以获得最高的效率，是首选的整数类型。</li>
</ul>
<h4 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h4><p>   反码和补码是针对一个特定的原码来说的。反码就是将原码01取反，补码就是在反码的基础上再加1。<br>   例如原码是<code>00001111</code>，反码就是<code>11110000</code>，补码就是<code>11110001</code>。<br>   计算机内部表示整数使用的是二进制的方法，但是int类型也可以为负整数，对于负整数，就需要用到反码和补码。<br>   int类型总共有32位，其中第一位是符号位，假如为0就是非负整数，否则是负整数，后面31位用来记录数字的信息。下面为了方便叙述，将32位的整型简化为8位。<br>   先考虑最高位是0的情况，那么这个数就是后面7位二进制表示的整数，例如(01010101)2=85。<br>   继续考虑第二种情况：最高位为1。此时这个二进制用来表示一个负数，这个负数的绝对值就是相应补码表示的正整数。例如(10101010)2，先将所有位都取反，得到(01010101)2，再加上1得到(01010110)2=86。因此(10101010)2表示的整数是-86。<br>   特别地，(11111111)2表示的是-1，(10000000)2表示的是-128。扩展到32位整数的话，全是1依然表示-1，第一位1后面全0表示-231。因此int类型能表示的最小值是-231，而不是-231+1。<br>   最后的问题是为什么要用这种方式来表示负数？<br>   大家可以自己验证一下，如果这样表示的话，加法减法时都无需考虑整数的符号，可以直接对二进制加减（第32位产生的进位需舍去），就能得到正确结果。<br>   但如果运算结果超出了类型能表示的范围，由于最高位的进位被舍去，计算出来的结果就会发生错误，所以要根据题目的数据范围选择合适的整数类型，必要的时候还需要使用高精度。<br>   还有特别需要注意，只有带符号的整型使用这种方式表示整数的，不带符号的整型是直接用二进制表示的（因为不需要表示负数）。  </p>
<h4 id="练习题1"><a href="#练习题1" class="headerlink" title="练习题1"></a>练习题1</h4><pre><code class="c++">    int a = 10;  // 正确
    const int b = a * 2;
    // 错误，常量必须是常量表达式
    int &amp;c;
    // 错误，引用类型定义时必须初始化
    char *d = &amp;a;
    // 错误，指针类型不匹配
    int x = 1000000000;  // 正确
    long long y = x * x;
    // 错误，没有进行显式类型转换，会导致溢出
</code></pre>
<h4 id="练习题2"><a href="#练习题2" class="headerlink" title="练习题2"></a>练习题2</h4><pre><code class="c++">    int a = 0xffff;
    // 十六进制，a的值为65535
    int b = 0xffffffff;
    // 十六进制，注意二进制全1表示-1，因此b的值是-1[计算机字长为64位时`0xffffffffffffffff`=-1]
    double c = 3.141592653;
    int d = c, e = (int)c; // d和e的值都是3
    char f = &#39;e&#39;;
    int g = f - &#39;a&#39;; // g的值是4
    double h = -1.2;
    int i = (int)h; // i的值是-1
    int &amp;x = d, *y = &amp;e;
    x ++; *y --; // d变成4，e变成2
</code></pre>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h4 id="四则运算符、取模"><a href="#四则运算符、取模" class="headerlink" title="四则运算符、取模"></a>四则运算符、取模</h4><p>   <code>+ - * /</code>，这个大家都懂得对吧。其中<code>/</code>需要注意一下，如果相除的两个变量(常量)都是整型，就会进行<code>整除操作</code>，否则进行<code>实数除法</code>。C++中的取模操作符是<code>%</code>，<strong>取模要求操作的两个类型都是<code>整型</code></strong>。  </p>
<pre><code class="c++">    int a = 10, b = 3;
    double c = 3.5;
    double d = a / c; // c是实型，因此是实型除法
    int e = a / b; // a,b都是整型，因此是整除
    double f = a / (double)b;
    // b被转换成实型，因此是实型除法
    int g = a / 4; // a和4都是整型，因此是整除
    double h = a / 4.0; // 4.0是实型，因此是实型除法
</code></pre>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>   <code>&lt; &gt; &lt;= &gt;= == != &amp;&amp; || !</code><br>   分别对应Pascal中的<code>&lt; &gt; = &lt;&gt; and or not</code><br>   到后面讲if语句时会具体举例<br>   逻辑运算符两边的类型不同时，也会进行隐式类型转换<br>   C++中的字符型(<code>char</code>)可以直接用在&lt;、&gt;、&lt;=、&gt;=、==、!=等逻辑比较中。例如a是char类型的变量，你可以用<code>(&#39;a&#39; &lt;= a &amp;&amp; a &lt;= &#39;z&#39;)</code>来判断a是否表示小写英文字母。  </p>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>   Pascal中也可以进行<code>位运算</code>，但是大家用的或许比较少。Pascal中的三种位运算是<code>and or xor</code>，C++中对应的运算符是<code>&amp;、|和^</code>。<br>   位运算就是把整数转换为二进制后，每位进行相应的运算得到结果。<strong> <code>&amp;</code>只有当两个都为1时才为1，<code>|</code>只要两个中有一个1就是1，<code>^</code>只有当两个不同时才为1 </strong>。<br>   例如：5=(101)2，6=(110)2，那么5&amp;6=(100)2=4、5|6=(111)2=7、5^6=(011)2=3。<br>   还有一类位运算是<code>左移</code>和<code>右移</code>，Pascal中是<code>shl</code>和<code>shr</code>，C++中是<code>&lt;&lt;</code>和<code>&gt;&gt;</code>。左移右移的作用就是将二进制表示整体移动，并舍去不在范围内的部分。例如5&lt;&lt;1=(1010)2=10、5&gt;&gt;1=(10)2=2。实际上可以看出，<strong>左移k位相当于乘上2k，右移k位相当于整除2^k</strong>。  </p>
<h6 id="amp-、-和-amp-amp-、"><a href="#amp-、-和-amp-amp-、" class="headerlink" title="&amp;、|和&amp;&amp;、||"></a>&amp;、|和&amp;&amp;、||</h6><p>   &amp;和|是按位与和或，而&amp;&amp;和||是逻辑与和或，观察下面的程序片段：  </p>
<pre><code class="c++">    int a = 10, b = 0;
    int c1 = a &amp; b, c2 = a &amp;&amp; b;
    int d1 = a | b, d2 = a || b;
</code></pre>
<p>   其中a&amp;b是按位与，a&amp;&amp;b的话，因为逻辑与要求两个数都是bool类型，因此会将a和b隐式转换为bool类型，其中a被转换为true，b被转换为false，计算完了之后又会被隐式转换为int类型赋值给c2。<br>   这样分析一下，c1、c2的值为0，d1的值为10，d2的值为1。  </p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>   赋值也是一种运算符，和Pascal中不同，C++中的赋值运算符是<code>=</code>，而不是:=。相应的，逻辑等于就是<code>==</code>，而不是=。这些细节在刚转C++的时候尤其要注意。<br>   赋值还可以和二元运算符结合，例如a+=b就表示将a+b赋值给a。其他类似的运算符还有<code>-=、*=、/=、%=、&amp;=、|=、^=、&lt;&lt;=、&gt;&gt;=</code>等。  </p>
<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>   C++中的表达式比Pascal中更广泛，表达式的主要特点就是它有“值”。<br>   例如加法表达式a+b，它的值就是加法运算的结果。再例如逻辑表达式a&gt;=b，它的值是逻辑运算的结果（true或false，也可以说0或1）。<br>   更高级的还有x=y这样的赋值，它也算表达式，它的值就是x（或y）的值。诸如+=的赋值表达式的值为左边变量赋值后的值。<br>   因为赋值也算作一种表达式，因此我们可以写出x=y=z这样的连赋值，要从右向左看这个表达式，它先把z的值赋值给y，再把y=z的值赋值给x，其实就是把z赋值给x和y。<br>   在表达式后面加上分号就能成为一条语句。  </p>
<h4 id="和–"><a href="#和–" class="headerlink" title="++和–"></a>++和–</h4><p>   <code>自加</code>和<code>自减</code>可以简单地看成Pascal中的inc和dec函数，但是它们有一些区别，区别就在于前面说的表达式，自加和自减操作也有<code>值</code>。<br>   自加和自减有两种形式：<code>前缀</code>和<code>后缀</code>。假如x为int类型的变量，<code>x++</code>和<code>++x</code>的含义是不同的，虽然都会将x加上1，但考虑下面的两个表达式：<br>   <code>y=x++和y=++x</code><br>   第一个的话，是先执行y=x、再将x加上一，第二个是先将x加上一、再执行y=x。用表达式的值来理解的话，前缀++和–会<code>返回操作过后的值</code>，后缀++和–会<code>返回操作之前的值</code>。可以用“<code>先用再加</code>”和“<code>先加再用</code>”来形象记忆。  </p>
<h4 id="注意：-和–"><a href="#注意：-和–" class="headerlink" title="注意：++和–"></a>注意：++和–</h4><p>   <strong>++、–这两种运算符使用时需要很小心，有时会写出难以解释的表达式，例如：<code>x = x / ++ x</code></strong><br>   按照运算符优先级，++高于/，因此先处理<code>++ x</code>运算。这里的问题是，除法两边都是x，第二个显然是加一后的x，但前面的x到底指加一前还是加一后呢？C++语法标准中认为这样的表达式有二义性，不同的编译器有可能给出不同的结果。因此在使用++和—运算符时要小心地避免这样的情况，要保证写出的表达式很容易被解释。<strong>基本上把握带有前缀后缀++或–的变量只在表达式中出现一次，就不会出现大问题了</strong>。</p>
<h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><p>   逗号可以分割多个表达式，并整体组成一个表达式，它的值为最后一个表达式的值，计算的时候按照从左到右的顺序。  </p>
<pre><code class="c++">    int a, b, c, d;
    // 这里是定义，和逗号表达式没关系
    d = (a = 10, b = 20, c = 30, a &lt;= b &amp;&amp; b &lt;= c);
    // **由于逗号运算符的优先级比赋值低，所以最外面有括号**
    // 整个逗号表达式的值为a &lt;= b &amp;&amp; b &lt;= c这个表达式的值，也就是1
    c = 100, d = 200;
    // 逗号表达式也可以简单起到将多个赋值合并为一条语句的作用
</code></pre>
<h4 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h4><p>   new用来申请动态内存空间，返回值是一个指针。例如：<br>   <code>int *p = new int;</code><br>   就会使p指向一个int类型。<br>   对于动态申请的空间，可以用<code>delete</code>删除。也就是：<br>   <code>delete p;</code><br>   <strong>注意delete操作并不会使p变为0，它只会清除p指向空间，最好下一句手动将0赋值给p(<code>p=0</code>)。</strong></p>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>   排在前面的优先级较大，同一组的优先级相同  </p>
<ul>
<li>Group 1<ul>
<li>++、–：后缀自加自减</li>
</ul>
</li>
<li>Group 2<ul>
<li>!：逻辑否</li>
<li>++、–：前缀自加自减</li>
<li>+、-：正负号</li>
<li>&amp;：取地址</li>
<li>(type)：显式类型转换</li>
</ul>
</li>
<li>Group 3<ul>
<li>*、/、<code>%</code>：乘法、除法、取模</li>
</ul>
</li>
<li>Group 4<ul>
<li>+、-：加法、减法</li>
</ul>
</li>
<li>Group 5<ul>
<li>&lt;&lt;、&gt;&gt;：按位左移、右移</li>
</ul>
</li>
<li>Group 6<ul>
<li>&lt;、&lt;=、&gt;、&gt;=：小于、小于等于、大于、大于等于</li>
</ul>
</li>
<li>Group 7<ul>
<li>==、!=：逻辑等于、逻辑不等于</li>
</ul>
</li>
<li>Group 8<ul>
<li>&amp;：按位与</li>
</ul>
</li>
<li>Group 9<ul>
<li>^：按位异或</li>
</ul>
</li>
<li>Group 10<ul>
<li>|：按位或</li>
</ul>
</li>
<li>Group 11<ul>
<li>&amp;&amp;：逻辑与</li>
</ul>
</li>
<li>Group 12<ul>
<li>||：逻辑或</li>
</ul>
</li>
<li>Group 13<ul>
<li>=、+=、-=、*=、/=、<code>%=</code>、&amp;=、^=、|=、&lt;&lt;=、&gt;&gt;=：赋值运算符</li>
</ul>
</li>
<li><p>Group 14</p>
<ul>
<li>,：逗号运算符</li>
</ul>
<p>大家特别需要注意的是，<code>位运算运算符</code>的优先级都比较低（低于<code>加法和减法</code>，有些低于<code>逻辑比较运算符</code>），使用的时候一定要加上适当的<code>括号</code>。</p>
</li>
</ul>
<h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><pre><code class="c++">    int a = 10, b = 3;
    int c = a / b;  // c的值为3
    double d = a / b;  // d的值仍然为3
    double e = (double)a / b;  // e的值为3.333……
    int f = a | b, g = a &amp;&amp; b;
    // f的值为11，g的值为1
    int h = a + b &gt;&gt; 2;
    // &gt;&gt;优先级比+低，h的值为3
    int i = a ++;
    // i的值为10，a的值变为11
    int j = -- b;
    // j的值为2，b的值变为2
</code></pre>
<h2 id="读入、输出"><a href="#读入、输出" class="headerlink" title="读入、输出"></a>读入、输出</h2><h3 id="C语言中的读入输出函数"><a href="#C语言中的读入输出函数" class="headerlink" title="C语言中的读入输出函数"></a>C语言中的读入输出函数</h3><p>   由于C++是C语言的扩展，因此可以使用C语言头文件中的函数。C语言中的读入函数是<code>scanf</code>，输出函数是<code>printf</code>，它们都是从屏幕读入输出。<br>   这两个函数都是先传入一个格式字符串，再给出要读入或输出的若干变量。<br>   注意如果要使用C语言的读入输出函数，需要<code>#include &lt;cstdio&gt;</code>。</p>
<h4 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h4><p>   scanf函数中的格式字符串用来指定依次读入的类型，例如下面的例子中<code>%d</code>表示以十进制方式读入一个<code>int</code>类型，<code>%lf</code>表示读入一个<code>double</code>类型。后面给的变量需要是指针类型，因此要在前面加<code>&amp;</code>。</p>
<pre><code class="c++">    int a;
    double b;
    scanf(&quot;%d%lf&quot;, &amp;a, &amp;b);
</code></pre>
<p>   （C++中的字符串是用双引号包围的）</p>
<h6 id="格式字符"><a href="#格式字符" class="headerlink" title="格式字符"></a>格式字符</h6><ul>
<li>%d – <strong>int</strong></li>
<li>%ld – long</li>
<li>%lld – <strong>long long (Linux)</strong></li>
<li>%I64d – <strong>long long (Windows)</strong></li>
<li>%u – unsigned</li>
<li>%lu – unsigned long</li>
<li>%llu – unsigned long long (Linux)</li>
<li>%I64u – unsigned long long (Windows)</li>
<li>%c – char</li>
<li>%f – float</li>
<li>%lf – <strong>double</strong></li>
</ul>
<h4 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h4><p>   和scanf类似，需要提供格式字符串，但是后面直接提供变量的值，不需要加&amp;操作符。  </p>
<pre><code class="c++">    int a = 10;
    double b = 2.5;
    printf(&quot;%d %.5lf\n&quot;, a, b);
</code></pre>
<p>   对于实数类型，用上面的方式可以<strong>四舍五入保5位小数</strong>输出。因此上面程序片段的输出结果是：<br>   10 2.50000<br>   （因为<strong>格式字符串中间有个空格，输出时中间也就有空格，并且最后会换行(\n)</strong>）<br>   printf函数中的<code>格式字符串</code>其实就是要打印的内容，只不过它把<code>%d</code>、<code>%c</code>之类的格式字符替换成后面提供的参数。所以你可以用printf函数直接输出字符串：<br>   <code>printf(&quot;Hello World\n&quot;);</code>  </p>
<h4 id="scanf函数和printf函数的返回值"><a href="#scanf函数和printf函数的返回值" class="headerlink" title="scanf函数和printf函数的返回值"></a>scanf函数和printf函数的返回值</h4><p>   scanf函数返回成功赋值的数据项数，读到文件末尾出错时则返回<strong>EOF</strong>。这里的EOF是在<code>cstdio头文件</code>中被定义的<code>宏</code>。<br>   printf函数返回实际输出的字符数。<br>   下面的程序可以不停地读入n后输出直到文件结束。   </p>
<pre><code class="c++">    int n;
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
       printf(&quot;%d\n&quot;, n);
</code></pre>
<h3 id="C-语言的读入输出字符"><a href="#C-语言的读入输出字符" class="headerlink" title="C++语言的读入输出字符"></a>C++语言的读入输出字符</h3><ul>
<li>char c=getchar();</li>
<li>putchar(c);</li>
</ul>
<h3 id="C-语言的读入输出流"><a href="#C-语言的读入输出流" class="headerlink" title="C++语言的读入输出流"></a>C++语言的读入输出流</h3><h4 id="cin-cout"><a href="#cin-cout" class="headerlink" title="cin/cout"></a>cin/cout</h4><p>   由于C++是面向对象的编程语言，对于读入输出的处理也更加对象化。由于OI竞赛中并不需要对面向对象的编程思想有太多了解，这里也不展开细说，看看下面的代码应该就很容易理解C++如何从屏幕读入输出。  </p>
<pre><code class="c++">    int x;
    double y;
    cin &gt;&gt; x &gt;&gt; y;
    cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;
</code></pre>
<p>   <code>cin</code>和<code>cout</code>是<code>iostream头文件</code>中定义好的类，因此要<code>#include &lt;iostream&gt;</code>后才能使用。读入数据时可以想象是从cin中拿出来，所以用&gt;&gt;运算符，输出时正好相反，因此使用&lt;&lt;运算符。最后的<code>endl</code>表示换行，也可以用’\n’代替。  </p>
<h4 id="输出流控制"><a href="#输出流控制" class="headerlink" title="输出流控制"></a>输出流控制</h4><ul>
<li>dec : 十进制输入输出</li>
<li>hex : 十六进制输入输出</li>
<li>oct : 八进制输入输出</li>
<li>setw(int width) : 设置场宽<ul>
<li>可以写为cout.width</li>
</ul>
</li>
<li>ws ： 提取空白符，即去掉<code></code>符</li>
<li>setprecision(int num) : 设置输出位数（包括整数、小数）<ul>
<li>使用fixed后，设置小数位数</li>
<li>一直作用，直到再次设置</li>
<li>可以写为cout.precision</li>
</ul>
</li>
<li>endl : 换行，并刷新流</li>
<li>ends : 终止符</li>
<li>setfill(int ch) : 填充字符<ul>
<li>可以写为cout.fill()</li>
</ul>
</li>
<li>put : 输出一个字符<ul>
<li>可以级联cout.put().put()…</li>
</ul>
</li>
<li>left/right : 左/右对齐</li>
</ul>
<h4 id="cin-get-cin-getline"><a href="#cin-get-cin-getline" class="headerlink" title="cin.get()/cin.getline()"></a>cin.get()/cin.getline()</h4><ul>
<li>cin.get<ul>
<li>读入一个字符作为返回值</li>
<li><code>char c=cin.get;</code></li>
</ul>
</li>
<li>cin.getline<ul>
<li>读入一个C-Style字符串</li>
<li><code>cin.getline(数组起始值,最大长度)</code></li>
<li><code>char c[80];&lt;br&gt;cin.getline(c,80); // cin.getline(c+1,79);从c[1]开始读</code></li>
<li>相当于<code>gets(数组起始值)</code></li>
</ul>
</li>
</ul>
<h4 id="如何选择读入输出方式"><a href="#如何选择读入输出方式" class="headerlink" title="如何选择读入输出方式"></a>如何选择读入输出方式</h4><p>   C语言的<code>scanf</code>函数和<code>printf</code>函数需要提供<code>格式字符串</code>，而C++语言的<code>cin</code>和<code>cout</code>只需要提供变量，这样看起来cin和cout显得更方便。不过在实际情况中，<strong>cin和cout的效率非常低下</strong>，读入或输出2MB的文件就有可能会超时（时限1s的情况），并且cout对于实数是选择一个合适的精度，要手动控制比较麻烦。因此大部分C++选手在OI竞赛中使用scanf和printf进行读入输出操作。<strong>使用scanf和printf读入输出long   long类型时需要特别注意使用的系统平台</strong>，用错格式符的话会产生无法正确读入输出的后果。<br>   还有要说明的是，scanf、printf和cin、cout默认情况下是同步的，也就是说你可以混用两种读入输出方式。例如对用long long类型使用cin、cout读入输出，就不需要特别注意系统平台的差异。  </p>
<p><strong>特别注意：有时不得不大量读入long long，需要使用cin/cout时，为了加快读入速度，可以使用下边的方式：</strong>  </p>
<pre><code class="c++">    std::ios::sync_with_stdio(false);
    std::cin.tie(0);//此时不要用scanf/printf了
</code></pre>
<h4 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h4><pre><code class="c++">    printf(&quot;%d\n&quot;, 10.0);
    // 格式字符错误，应该用%lf
    printf(&quot;%.5lf\n&quot;, 5);
    // 格式字符错误，应该用%d
    int a, b;
    scanf(&quot;%d%d&quot;, a, b);
    // a和b前面缺少&amp;
</code></pre>
<h2 id="数据结构、常用函数"><a href="#数据结构、常用函数" class="headerlink" title="数据结构、常用函数"></a>数据结构、常用函数</h2><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>   数组有个很文艺的名称：随机存取线性表。其实数组就是多个相同类型的变量依次排在一段连续的内存中。C++语言中的数组长度不可变。下面的程序片段中定义了一个长度为10的int数组a，可用的下标是0..9（你只能指定数组的长度，不能像Pascal中那样指定下标的上下界）。</p>
<pre><code class="c++">    int a[10];
    a[0] = a[9] = 1;

    a[10] = 1;
    // 数组下标越界，但运行时未必会给出异常
    int n;
    int b[n]; // 数组长度必须是常量
</code></pre>
<h6 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h6><p>   C++中数组的长度可以是<code>变量</code>，但是定义之后便不可改变。如果说用变量作为数组的长度，那么数组的长度为执行定义的语句时那个变量的值。<strong>一般来说，我们都将数组定义成全局变量，由于全局变量在主函数之前，就没法用读入的数作为数组长度定义数组，因此一般情况下还是将数组长度指定为常数，并且要看清题目数据范围，不要把数组开小</strong>。</p>
<h4 id="一维数组和指针的关系"><a href="#一维数组和指针的关系" class="headerlink" title="一维数组和指针的关系"></a>一维数组和指针的关系</h4><p>   由于数组相当于内存中一段连续的空间，因此将刚才定义的数组a画成下面的形式：<br>   下面的箭头表示指向相应位置的指针。例如指向<code>a[0]</code>的指针就是<code>a</code>（或看成a+0），也就是说<code>&amp;a[0]==a</code>。然后<code>&amp;a[1]==a+1</code>，以此类推直到<code>&amp;a[9]==a+9</code>。这也就是说，如果a是某种类型的数组，那么它可以看成这种类型的指针。  </p>
<h4 id="指针的加减法"><a href="#指针的加减法" class="headerlink" title="指针的加减法"></a>指针的加减法</h4><p>   前面解释一维数组和指针的关系时，已经用到了将一个指针和整数相加的运算，除此之外，两个指针还可以相减。例如下面的程序片段：  </p>
<pre><code class="c++">    int a[10];
    int *p = &amp;a[2], *q = &amp;a[5];
    int t = q - p;  // q - p的值为3
</code></pre>
<p>   注意到p实际上就是a+2，q实际上就是a+5，因此很自然的能得出q-p=(a+5)-(a+2)=3。<br>   除了将指针加上或减去一个整数以外，也能够对指针进行++和–。<br>   总结一下指针加减法：一个指针可以加上或减去一个整数，两个指针可以相减得到一个整数。  </p>
<h4 id="再谈new和delete"><a href="#再谈new和delete" class="headerlink" title="再谈new和delete"></a>再谈new和delete</h4><p>   new操作符其实可以申请多于一个指定类型的空间，例如下面的程序片段：<br>   <code>int *a = new int[10];</code><br>   <code>new int[10]</code>申请了连续10个int类型，并返回了指向第一个int的指针，这其实和数组是一样的。将这个指针赋值给int指针a后，a就可以当做数组使用，也就是说<code>a[5]=1</code>这类的赋值都是合法的。你可以这样理解，编译器对于<code>[]</code>运算符，实际上是进行了指针的加法，也就是说<code>a[5]</code>被理解为<code>*(a+5)</code>，所以只要a是指针类型，就能使用[]运算符，但是你要保证你给的下标是有意义的。<br>   清理空间时，要使用这样的语句：<code>delete[] a</code>;<br>   使用new申请空间时的长度可以是变量。也就是你也可以这样写：<code>int *a = new int[n]</code>;<br>   <em>出于效率的考虑，多数情况下我们不用这样的方法代替数组。</em>  </p>
<h4 id="高维数组"><a href="#高维数组" class="headerlink" title="高维数组"></a>高维数组</h4><p>   除了一位数组之外，C++也支持高维数组，直接看下面的程序片段：</p>
<pre><code class="c++">    int a[10][10], b[10][10][10];
    a[1][1] = 1;
    b[1][1][1] = 1;
</code></pre>
<p>   上面的程序片段中定义了一个<code>二维数组a</code>和一个<code>三维数组b</code>，所有下标的范围都是<code>0..9</code>。<br>   C++中的高维数组访问和Pascal不一样，不是用逗号分隔，而是用多对方括号。（其实Pascal中也支持这样的访问方式）</p>
<h4 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h4><p>   C语言里用字符数组来存储字符串，后面讲到STL时会再谈到C++中的string类。<br>   C风格的字符串可以表示为指向char的指针，也就是char*。这个指针指向字符串第一个字符的位置，后面的字符就是依次往后加，如果遇到了字符’\0’（ASCII码为0的字符），就表示字符串结束了，其中’\0’不是字符串的一部分。<br>   <code>char *str = &quot;abcd&quot;;</code><br>   观察上面这条赋值语句。其中”abcd”是常量字符串，编译器在编译时，会在内存某块区域申请连续5个char，依次赋值为’a’、’b’、’c’、’d’、’\0’，然后将指向’a’的指针赋值给str。<br>   如果我们想要创建字符串，可以定义一个char数组，然后依次赋值。例如下面的程序片段，虽然str是长度为10的数组，但是str也可以看成char*类型，它的前五个字符正好能看成一个完整的字符串。 </p>
<pre><code class="c++">    char str[10];
    str[0] = &#39;a&#39;; str[1] = &#39;b&#39;;
    str[2] = &#39;c&#39;; str[3] = &#39;d&#39;;
    str[4] = &#39;\0&#39;;
</code></pre>
<h4 id="读入、输出C风格字符串"><a href="#读入、输出C风格字符串" class="headerlink" title="读入、输出C风格字符串"></a>读入、输出C风格字符串</h4><p>   scanf函数和printf函数可以读入输出C风格的字符串，使用的格式字符是<code>%s</code>：  </p>
<pre><code class="c++">    char str[10];
    scanf(&quot;%s&quot;, str);
    printf(&quot;%s\n&quot;, str);
</code></pre>
<p>   由于str等价于指向char的指针，因此scanf中传递的参数是<code>str</code>，而不是&amp;str。<br>   还有scanf函数读入时，<code>空白字符（空格、制表符、换行等）</code>都会作为<code>分隔符</code>，并且它会在字符串最后一个字符后面加上<code>&#39;\0&#39;</code>，也就是说长度为10的字符数组最多只能存储长度为9的字符串，所以开数组的时候要注意多开1.  </p>
<h4 id="其他读入输出函数"><a href="#其他读入输出函数" class="headerlink" title="其他读入输出函数"></a>其他读入输出函数</h4><p>   用scanf函数读入字符串时，遇到<code>空白字符</code>就会停下，有时候题目要求读入一行字符串，这时候我们就可以使用<code>gets</code>函数。  </p>
<pre><code class="c++">    char str[1000];
    gets(str);
</code></pre>
<p>   <code>gets(str)</code>会将当前行剩下的字符依次存入str中，并在最后加上’\0’，因此你需要确保str数组的长度是足够的。上面的程序片段中，str数组只能存储长度为999的字符串。<br>   类似的，使用<code>puts</code>函数可以输出一个字符串（<strong>输出字符串后不会自动输出一个换行</strong>）。<br>   还有<code>getchar</code>和<code>putchar</code>可以读入输出单个字符。<strong>需要注意<code>换行字符、空白字符</code>都会被<code>getchar</code>读到。</strong>  </p>
<pre><code class="c++">    char str[1000];
    gets(str);
    puts(str);
    char ch;
    ch = getchar();
    putchar(ch);
</code></pre>
<h4 id="cstring头文件"><a href="#cstring头文件" class="headerlink" title="cstring头文件"></a>cstring头文件</h4><p>   cstring头文件中包含一些处理C风格字符串的函数，主要介绍下面两个函数的用法：  </p>
<ul>
<li>unsigned strlen(char *str);</li>
<li>int strcmp(char <em>str1, char </em>str2);</li>
</ul>
<h5 id="strlen函数"><a href="#strlen函数" class="headerlink" title="strlen函数"></a>strlen函数</h5><p>   strlen函数可以计算字符串的长度，它的原理其实就是从给定的指针开始往后，遇到’\0’时停止。   </p>
<pre><code class="c++">    int a = strlen(&quot;abcd&quot;);  // a = 4
    char b[10];
    b[0] = &#39;a&#39;;
    b[1] = &#39;b&#39;;
    b[2] = &#39;c&#39;;
    b[3] = &#39;\0&#39;;
    int c = strlen(b); // c = 3
</code></pre>
<h5 id="strcmp函数"><a href="#strcmp函数" class="headerlink" title="strcmp函数"></a>strcmp函数</h5><p>   strcmp(str1, str2)用来比较字符串str1和str2，返回值类型为int，返回值为-1说明str1字典序比str2小，返回值为0说明相等，返回值为1说明str1字典序比str2大。  </p>
<pre><code class="c++">    char a[10], b[10];
    scanf(&quot;%s%s&quot;, a, b);
    int c = strcmp(a, b);
</code></pre>
<h5 id="strcat函数"><a href="#strcat函数" class="headerlink" title="strcat函数"></a>strcat函数</h5><p>   strcat(str1,str2)用来连接字符串str1,str2结果保存在str1中，所以记得要把数组开的足够大</p>
<pre><code class="c++">    char a[]=&quot;12345&quot;,b[]=&quot;67890&quot;;
    strcat(a,b);  //TIPs:不可以写成 a=b;
    cout&lt;&lt;a;  //输出1234567890
</code></pre>
<h5 id="strcpy函数"><a href="#strcpy函数" class="headerlink" title="strcpy函数"></a>strcpy函数</h5><p>   strcpy(str1,str2)用来将str2拷贝至str1中，注意数组大小</p>
<pre><code class="c++">    char a[]=&quot;12345&quot;,b[]=&quot;67890&quot;;
    strcpy(a,b);
    cout&lt;&lt;a;  //输出67890
</code></pre>
<h4 id="什么时候使用C风格字符串？"><a href="#什么时候使用C风格字符串？" class="headerlink" title="什么时候使用C风格字符串？"></a>什么时候使用C风格字符串？</h4><p>   特别需要说明的是，你没法用运算符来进行C风格字符串的相关操作，包括赋值、比较、连接等。后面会讲到C++的string类，使得你可以用运算符来完成字符串的很多操作。<br>   由于不能使用运算符对C风格字符串进行操作，因此对于字符串操作题，一般不使用C风格字符串，而会使用STL中的string类。<br>   但是有些题目只是读入字符串做一些简单判断，或只需要读取字符串的字符，这种时候用C风格字符串可以获得最好的效率。  </p>
<h4 id="memset函数"><a href="#memset函数" class="headerlink" title="memset函数"></a>memset函数</h4><p>   memset函数常用来给一个数组清0。一般写法是如下形式：  </p>
<pre><code class="c++">    int a[100];
    memset(a, 0, sizeof(a));
</code></pre>
<p>   memset的工作方式是每个字节赋值成第二个参数的值，第一个参数表示开始赋值的位置，第三个参数表示赋值的字节数。sizeof(a)可以算出a数组占用的字节数。<br>   除了清零之外，也可以用memset函数对数组整体赋值其他的值。  </p>
<pre><code class="c++">    bool a[100];
    memset(a, true, sizeof(a));
    int b[100];
    memset(b, 255, sizeof(b));
    char c[100];
    memset(c, &#39;a&#39;, sizeof(c));
</code></pre>
<p>   其中bool数组a被清成了true，字符数组c被清成了字符’a’。int数组b被清成了-1，因为每个int四个字节的每个字节都是全1，所以最终的值是-1。  </p>
<h4 id="memcpy函数"><a href="#memcpy函数" class="headerlink" title="memcpy函数"></a>memcpy函数</h4><p>   memcpy函数可以用来复制数组：  </p>
<pre><code class="c++">    int a[100], b[100];
    memcpy(a, b, sizeof(b));
</code></pre>
<p>   第一个参数表示目标数组，第二个参数被复制的数组，第三个参数表示复制的字节数。上面的用法就相当于把b数组的内容复制到a数组。<strong>假如a数组长度小于b数组，就会出现问题。假如a数组长度大于b数组，只有a数组的前100个int会被复制成b数组的内容，后面的保持不变。一般只会对长度相同、类型相同的数组使用memcpy。</strong>  </p>
<h6 id="memset和memcpy的注意点"><a href="#memset和memcpy的注意点" class="headerlink" title="memset和memcpy的注意点"></a>memset和memcpy的注意点</h6><p>   这两个函数都在头文件cstring中，因此使用时需要<code>#include &lt;cstring&gt;</code>。<br>   memset和memcpy中都用到了<code>sizeof运算符</code>（没错，它其实是运算符，sizeof(a)可以写成sizeof a），sizeof运算符会计算给定变量或常量占用的字节数。对于数组类型，它会计算出整个数组占用的字节数。<strong>需要注意的是，如果你是用new申请了一段空间后赋值给一个指针，sizeof这个指针会得到这个指针类型占用的字节数（32位系统下是4字节），而不会得到new申请的字节数。</strong><br>   如果不太明白可以看下面的例子：  </p>
<pre><code class="c++">    int *a = new int[10];
    int x = (int)sizeof(a); // x = 4
    int b[10];
    int y = (int)sizeof(b); // y = 4 * 10
</code></pre>
<p>   同样的情况还发生在函数的参数中，后面还会再提到。  </p>
<h6 id="分清指针和数组名"><a href="#分清指针和数组名" class="headerlink" title="分清指针和数组名"></a>分清指针和数组名</h6><p>   数组名可以看成常量指针（不可修改），但和指针是有本质区别的。<br>   sizeof一个数组名得到的是整个数组占用的字节数，而sizeof一个指针得到的是4（32位系统下指针类型占用4字节）。  </p>
<pre><code class="c++">    int a[10]; // 数组名
    int *b; // 指针
    int *c = new int[10]; // 指针！

    b = c; // 合法赋值
    a = c; // 非法赋值！！
</code></pre>
<h4 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h4><p>   定义数组时，通常不能确保数组元素的初始值是0这样的值，比较保险的方法是在使用数组前对数组元素的值进行正确的初始化。<br>   前面已经说过了用memset对数组整体赋值，除此之外，对于一维数组也可以在定义时赋初始值。  </p>
<pre><code class="c++">    int a[5] = {0, 1, 2, 3, 4};
    int b[5] = {0, 1, 2};
</code></pre>
<p>   数组a的元素依次被初始化为0、1、2、3、4。数组b的话，前三个元素被初始化为0、1、2，最后两个元素使用默认值0。也就是说如果提供的数字个数不够了，剩下的元素就会用默认值0。<br>   初始化字符数组时，我们还可以直接用下面的形式：<br>   <code>char a[10] = &quot;abc&quot;;</code><br>   数组a的前三个元素会依次被赋值为’a’、’b’、’c’，后面的元素都是’\0’。<br>   <strong>需要注意的是数组的长度必须够存储初始化的字符串，也就是数组长度至少要是字符串长度加一</strong>。  </p>
<h4 id="常量数组"><a href="#常量数组" class="headerlink" title="常量数组"></a>常量数组</h4><p>   有时候为了方便编程，我们会定义常量数组。例如迷宫里只能向四个方向走时，我们可以定义一个二维的位移量数组：<br>      <code>const int u[4][2] =</code>{<code>{0, 1}, {0, -1}, {1, 0}, {-1, 0}</code>}<code>;</code><br>   定义一维常量数组时可以不指定数组的大小，编译器会根据你提供的内容算出数组的大小：<br>      <code>const int t[] = {1, 2, 3, 4, 5};</code>  </p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>   结构体和Pascal中的record类似，可以将一些不同的类型放在一起：  </p>
<pre><code class="c++">    struct person {
       char name[100];
       int age;
       bool sex;
    };                         //要有分号！！
    person Jack;               //定义方式1
    Jack.age = 30;             //访问方式2
    Jack.sex = true;
    person *Bob = new person;  //定义方式2
    Bob-&gt;age = 18;             //访问方式2
    Bob-&gt;sex = true;
</code></pre>
<p>   从前面的程序片段中可以看出，struct相当于是用户创建了一种新类型，这里创建的struct类型名为person，有三个域name、age和sex。后面访问时用’.’来访问域。如果是指针的话，可以直接用-&gt;访问域，而不用先用’*’再用’.’。<br>   需要注意结构体定义右花括号后要有分号，不过其实可以在这个分号之前定义这个结构体的变量。例如：  </p>
<pre><code class="c++">    struct person {
        // 这里和前面一样，为了节约篇幅省略
    } Jack, *Bob;    //定义方式3
</code></pre>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>   C++中的枚举类型和Pascal中的类似。  </p>
<pre><code class="c++">    enum color {
       red, green, blue
    } x;
    color y;
    x = red;
    y = blue;
</code></pre>
<p>   上面的程序片段中定义了枚举类型color，然后还定义了color类型的变量x和y。<br>   枚举类型和int类型是可以相互转化的。实际上枚举类型中的每种取值对应了一个数字，默认情况按照定义时候的顺序从0开始，当然也是可以人为地指定每种取值对应的数值。<br>   前面的例子中，red对应0，green对应1，blue对应2。<br>   通过隐式或显式类型转换，可以把枚举类型转换为int，也可以把int转换为枚举类型。   </p>
<h4 id="练习题1-1"><a href="#练习题1-1" class="headerlink" title="练习题1"></a>练习题1</h4><pre><code class="c++">    int t[10]; // 正确
    t[10] = 1; // 错误，下标越界
    char a[10] = &quot;abcd&quot;; // 正确，初始化字符数组
    a = &quot;abc&quot;;
    // 错误，数组名虽然是指针，但不可改变取值
    int *b = new int[10]; // 正确
    memset(b, -1, sizeof(b)); // 错误，sizeof(b)为4
    int c[100]; // 正确
    memset(c, -1, sizeof(c));
    // 正确，c中的元素都被初始化为-1
    char d[4] = &quot;abcd&quot;; // 错误，数组长度至少要为5
</code></pre>
<h4 id="练习题2-1"><a href="#练习题2-1" class="headerlink" title="练习题2"></a>练习题2</h4><pre><code class="c++">    int a[5] = {5, 4, 3, 2, 1};
    printf(&quot;%d\n&quot;, *a); // 输出a[0]，即5
    printf(&quot;%d\n&quot;, *(a + 3)); // 输出a[3]，即2
    printf(&quot;%d\n&quot;, (int)sizeof(a)); // 输出20
    int *b = new int[5];
    printf(&quot;%d\n&quot;, (int)sizeof(b)); // 输出4
    char a[10] = &quot;abcde&quot;;
    printf(&quot;%d\n&quot;, (int)strlen(a)); // 输出5
    printf(&quot;%d\n&quot;, (int)sizeof(a)); // 输出10
</code></pre>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(https://ws1.sinaimg.cn/large/005wa3kugy1fu0b1mr5wsj318g18g3z8.jpg);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="https://ws1.sinaimg.cn/large/005wa3kugy1fu0b7kqj80j30e80e874f.jpg" alt="lqz's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        lqz@lqz.wind-flower.cn
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="lqz@lqz.wind-flower.cn" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2018/08/">八月 2018<span class="sidebar_archives-count">1</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
        <li>
            <a href="/archives">
                文章总数
                <span class="sidebar-badge">1</span>
            </a>
        </li>
        
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
    
    <!-- V2EX -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>Lqz'blog
            
                <br>
                
                    written by Lqz
                
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->

    
        
            <script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==", true)</script>
        
    



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })
        
    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.0 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
